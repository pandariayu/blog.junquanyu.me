### **边界值分析 (Boundary-Value Analysis, BVA)**

#### **1. 为什么需要 BVA？**

BVA 是对输入分区技术的一种重要补充和优化 。实践经验表明，大量的程序错误（如“差一错误” Off-by-one error）往往发生在输入域的“边界”或“边缘”上，而不是在等价类的中间 。BVA 通过系统地关注这些边界来设计测试用例，从而更有效地发现缺陷 。

#### **2. 识别边界：开边界与闭边界**

- **闭边界 (Closed Boundary)**：边界上的点属于该区域。通常由包含等号的运算符定义，如`<=`, `>=`, `=` 。
- **开边界 (Open Boundary)**：边界上的点不属于该区域。通常由不包含等号的不等式运算符定义，如`<`, `>` 。

#### **3. 核心概念：On-Point 和 Off-Point**

- **On-Point (在点上)**：指正好位于等价类边界上的一个点 。
- **Off-Point (离点)**：指紧邻边界的、刚刚越过边界的点 。

**示例**：

- 对于范围
    `$x <= 5$` (闭边界) ：
    
    - On-point 是
        `$x=5$` 。
        
    - 紧邻的 Off-point 是
        `$x=6$`（在边界外）。
        
- 对于范围
    `$x < 5$` (开边界) ：
    
    - On-point 仍然是
        `$x=5$` 。
        
    - 紧邻的 Off-point 是
        `$x=4$`（在边界内）。

#### **4. BVA 指导方针**

讲座提供了一套选择 On-point 和 Off-point 的启发式准则 ：

![](images/Pasted%20image%2020250906214706.png)

#### **5. BVA 应用于多维边界**

当程序的输入涉及多个变量时，边界会变成线、面或超平面。

- **二维边界**：例如，一个边界由 `$x >= y$` 定义。此时，测试不仅要考虑边界本身（`$x = y$`, on-point），还要考虑边界可能发生的偏移（shift）或旋转（pivot） 。
    
    - **挑战**：仅选择一个 on-point（如 `(0,0)`）和一个 off-point（如 `(0,1)`）可能无法检测到边界的旋转 。
    - **经验法则**：为了有效地“固定”住二维边界，应选择**两个相距较远的 on-points** 和一个**紧邻边界的 off-point** 。
    
- **N维边界**：这个规律可以推广到更高维度。对于一个 N 维的输入空间，通常需要选择 **N 个 on-points** 来“锚定”边界，并选择 **1 个 off-point** 来检测偏移 。

#### **6. BVA 实例：`binarySearch`**

对于

`binarySearch` 函数，我们可以对输入 `list` 的长度和 `target` 的值进行 BVA 。

- **对 `list` 长度的 BVA**：
    
    - 等价类为：`len(list) = 0`, `len(list) = 1`, `len(list) > 1`。
        
    - 边界点是 0 和 1。
        
    - 应用BVA后，需要测试的列表长度为：
        
        **0 (on-point), 1 (on/off-point), 2 (off-point)** 。
        
- **对 `target` 值的 BVA**：
    
    - 有效范围是 `1 <= target <= 100`。
        
    - 边界点是 1 和 100。
        
    - 应用BVA后，需要测试的
        
        `target` 值为：**0 (off-point), 1 (on-point), 100 (on-point), 101 (off-point)** 。

### **第三部分：控制流分析与覆盖率**

当我们可以查看源代码时，就可以采用

**白盒测试**技术 。控制流分析是最常见的白盒测试形式 。

#### **1. 控制流图 (Control-Flow Graph, CFG)**

- **定义**：CFG 是一种图形化表示，它展示了程序执行过程中所有可能的路径 。
    
    - **节点 (Nodes/Vertices)**：代表程序语句或语句块 。
        
    - **边 (Edges)**：代表节点之间的控制流 。对于条件语句（如
        
        `if`、`while`），边会被标记为 `True` 或 `False` 。
        
- **优点**：CFG 是一种独立于具体编程语言的抽象模型，有助于我们系统地分析程序的逻辑和分支 。
    

#### **2. 覆盖率标准 (Coverage Criteria)**

覆盖率是衡量测试用例对源代码测试得有多彻底的度量。

- **语句/节点覆盖 (Statement/Node Coverage)**：
    
    - **目标**：确保程序中的**每一个语句（或CFG中的每个节点）** 都至少被执行一次 。
        
    - **`binarySearch` 示例**：通过两个测试用例 `List = [], target = 4` 和 `List = [1,4,5,7,9], target = 4` 即可达到100%的语句覆盖 。
        
- **分支/决策/边覆盖 (Branch/Decision/Arc Coverage)**：
    
    - **目标**：确保程序中**每个决策点的所有可能分支（或CFG中的每条边）** 都至少被执行一次 。
        
    - **强度比较**：**分支覆盖比语句覆盖更强** 。因为满足分支覆盖必然会执行所有语句，但反之则不然（例如，一个没有
        
        `else` 的 `if` 语句，只测试 `true` 的情况也能覆盖所有语句，但没有覆盖 `false` 分支） 。
        

#### **3. 分支覆盖的变体**

对于复杂的条件判断（如 `if (x && y)`），分支覆盖还可以进一步细化：

- **条件覆盖 (Condition Coverage)**：
    
    - **目标**：确保每个**独立的子条件**都至少取过一次 `true` 和 `false` 。它不关心整个决策的最终结果 。
        
- **决策/条件覆盖 (Decision/Condition Coverage)**：
    
    - **目标**：**同时满足**条件覆盖和分支覆盖 。即每个子条件都取过
        
        `true`/`false`，并且整个决策的最终结果也取过 `true`/`false` 。
        
- **多重条件覆盖 (Multiple-Condition Coverage)**：
    
    - **目标**：覆盖决策中所有子条件的**所有可能组合** 。这是最强的覆盖标准，但可能需要大量的测试用例。